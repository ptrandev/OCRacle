\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
March 13, 2025 & 1.0 & Initial Document Creation\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{https://github.com/ptrandev/OCRacle/blob/main/docs/SRS/SRS.pdf}
for symbols, abbreviations and acronyms.

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\progname{}, an optical character recognition (OCR) program for identifying
Latin alphabet characters.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/ptrandev/OCRacle/}.

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
unsigned 8-bit integer & uint8 & an integer in [0, 255]\\
bounded real & $\mathbb{R}_{\text{min} \leq x \leq \text{max}}$ & a real number in the range [$\text{min}$, $\text{max}$]\\
File & File & a file object supported by Python\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding} &
Input Format Module\\
& Model Output Module\\
& Model Training Module\\
& Model Testing Module\\
& Prediction Model Module\\
& Application Module\\
& Performance Metrics Module\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision} &
Image Preprocessing Module\\
& Performance Metrics Module\\
& Graphical User Interface Module\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of Application Module} \label{MApplication}

\subsection{Module}

main

\subsection{Uses}

\begin{itemize}
  \item Graphical User Interface Module \ref{MGUI}
  \item Input Format Module \ref{MInput}
  \item Model Output Module \ref{MOutput}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
main & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

The Graphical User Interface module is responsible for handling all user
inputs and outputs. The Application module is responsible for coordinating the
interaction between the GUI, Input Format, and Model Output modules.

\subsubsection{Access Routine Semantics}

\noindent main():
\begin{itemize}
\item transition: The application is started and the user is able to interact
with the GUI to input images and view the model's predictions.
\end{itemize}


\subsubsection{Local Functions}

N/A

\section{MIS of Input Format Module} \label{MInput}

\subsection{Module}

input

\subsection{Uses}

\begin{itemize}
  \item Image Preprocessing Module \ref{mPreprocessing}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{2cm} p{3cm} p{6cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
input & filePath: string & imageMatrix: uint8$_{28 \times 28}$ & DimensionsError, FormatError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

N/A

\subsubsection{Access Routine Semantics}

\noindent input(filePath):
\begin{itemize} 
\item output: imageMatrix := preprocessing(file)
\item exception: A DimensionsError exception is thrown if the input image
exceeds the bounds of the $n_{min}$, $n_{max}$, $m_{min}$, and $m_{max}$
parameters as specified by the SRS. A FormatError exception is thrown if the
input image is not one of the supported formats.
\end{itemize}

\subsubsection{Local Functions}

\noindent readImage(filePath):
\begin{itemize} 
\item output: File object. A file object is returned that can be used to
read the image file by the preprocessing module.
\item exception: A FormatError is thrown if the input image is not one of the
supported formats.
\end{itemize}

\section{MIS of Model Output Module} \label{MOutput}

\subsection{Module}

output
\subsection{Uses}

\begin{itemize}
  \item Prediction Model Module \ref{MModel}
\end{itemize}


\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
  \item LABELS: \{'A',...,'Z'\}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
output & imageMatrix: uint8$_{28 \times 28}$ & prediction: char, confidenceMatrix: $\mathbb{R}_{\text{0} \leq \text{x} \leq \text{1}}^{26}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

We assume that the image matrix has been preprocessed as specified in the SRS
before being passed to the prediction model used by the output module.
\subsubsection{Access Routine Semantics}

\noindent output(imageMatrix):
\begin{itemize}
\item output: prediction, confidenceMatrix := predict(imageMatrix)
\end{itemize}

\subsubsection{Local Functions}

N/A

\section{MIS of Model Training Module} \label{MTraining}

\subsection{Module}

train

\subsection{Uses}

\begin{itemize}
  \item Performance Metrics Module \ref{MPerformance}
  \item Model Output Module \ref{MOutput}
  \item Input Format Module \ref{MInput}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
train & - & model: float32$_{\text{m} \times \text{n}}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item dataset: (uint8$_{28 \times 28}$, char)[]
  \item epochs: $\mathbb{N}$
  \item batch\_size: $\mathbb{N}$
  \item learning\_rate: $\mathbb{R}$
  \item epsilon: $\mathbb{R}$
  \item time\_step: $\mathbb{R}$
  \item first\_moment: $\mathbb{R}$
  \item second\_moment: $\mathbb{R}$
  \item beta1: $\mathbb{R}$
  \item beta2: $\mathbb{R}$
  \item gradient: float32$_{\text{m} \times \text{n}}$
  \item theta: float32$_{\text{m} \times \text{n}}$
  \item y\_hat: $float32_{\text{m} \times \text{n}}$
\end{itemize}

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

N/A

\subsubsection{Access Routine Semantics}

\noindent train():
\begin{itemize}
\item transition: The model is trained on the dataset using the hyperparameters
epochs, batch\_size, learning\_rate, epsilon, time\_step, first\_moment,
second\_moment, beta1, and beta2. These are manipulated via the ADAM optimizer
as specified by the SRS.
\item output: model := $f_{train}()$
\end{itemize}

\subsubsection{Local Functions}

\noindent relu(x):
\begin{itemize}
\item output: result := max(0, x)
\end{itemize}

\noindent softmax(x):
\begin{itemize}
\item output: result := $e^{x} / \sum_{i=1}^{n} e^{x_i}$
\end{itemize}

\noindent cnn\_forward(x, theta):
\begin{itemize}
\item transition: y\_hat := $f_{cnn\_forward}(x, theta)$. This function
calculates the output of the model given the input x and the weights theta.
\end{itemize}

\noindent cnn\_backward(x, y, y\_hat, theta):
\begin{itemize}
\item transition: gradient := $f_{cnn\_backward}(x, y, y\_hat, theta)$. This
function calculates the gradient of the model given the input x, the target y,
the output y\_hat, and the weights theta.
\end{itemize}

\noindent updateTheta(gradient, theta, time\_step, first\_moment, second\_moment, beta1, beta2, epsilon):
\begin{itemize}
\item transition: theta := $f_{updateTheta}(gradient, theta, time\_step, first\_moment, second\_moment, beta1, beta2, epsilon)$. This function updates the weights of the model using the ADAM optimizer.
\end{itemize}


\section{MIS of Model Testing Module} \label{MTesting}

\subsection{Module}

test

\subsection{Uses}

\begin{itemize}
  \item Performance Metrics Module \ref{MPerformance}
  \item Model Output Module \ref{MOutput}
  \item Input Format Module \ref{MInput}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{2cm} p{6cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
test & - & loss: $\mathbb{R_{\text{0} \leq \text{x} \leq \text{1}}}$, accuracy: $\mathbb{R_{\text{0} \leq \text{x} \leq \text{1}}}$, confusionMatrix: $\mathbb{R_{\text{0} \leq \text{x} \leq \text{1}}}^{26 \times 26}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item dataset: (uint8$_{28 \times 28}$, char)[]
  \item loss: $\mathbb{R_{\text{0} \leq \text{x} \leq \text{1}}}$
  \item accuracy: $\mathbb{R_{\text{0} \leq \text{x} \leq \text{1}}}$
  \item confusionMatrix: $\mathbb{R_{\text{0} \leq \text{x} \leq \text{1}}}^{26 \times 26}$
\end{itemize}

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

The model has a valid weight format for the test dataset and was trained using
the same hyperparameters as the training module.

\subsubsection{Access Routine Semantics}

\noindent test():
\begin{itemize}
\item transition: The model is tested on a dataset of unseen images. The loss,
accuracy, and confusion matrix are calculated using the model's predictions.
\item output: loss, accuracy, confusionMatrix := crossEntropyLoss(prediction,
target), accuracy(prediction, target), confusionMatrix(prediction, target)
\end{itemize}

\subsubsection{Local Functions}

N/A


\section{MIS of Prediction Model Module} \label{MModel}

\subsection{Module}

model

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
predict & imageMatrix: uint8$_{28 \times 28}$ & confidenceMatrix: $\mathbb{R}_{\text{0} \leq \text{x} \leq \text{1}}^{26}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item model: float32$_{\text{m} \times \text{n}}$
\end{itemize}

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

We assume that the input image has been preprocessed as specified in the SRS
before being passed to the prediction model.


\subsubsection{Access Routine Semantics}

\noindent predict(imageMatrix):
\begin{itemize}
\item output: confidenceMatrix := $f_{predict}(imageMatrix)$
\end{itemize}



\subsubsection{Local Functions}

N/A

\section{MIS of Image Preprocessing Module} \label{mPreprocessing}

\subsection{Module}

preprocessing

\subsection{Uses}

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{3cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
preprocessing & file : File & imageMatrix: uint8$_{28 \times 28}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

All input data has been validated by the Input Format Module before being
processed by the Image Preprocessing Module.

\subsubsection{Access Routine Semantics}

\noindent preprocessing(file):
\begin{itemize} 
\item output: image := $uint8_{28 \times 28}$.
The input file has been transformed such that it conforms to the preprocessing
requirements as specified by the SRS.
\end{itemize}

\subsubsection{Local Functions}

N/A

\section{MIS of Performance Metrics Module} \label{MPerformance}

\subsection{Module}

performance

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
crossEntropyLoss & prediction: float32$_{\text{m} \times \text{n}}$, target: float32$_{\text{m} \times \text{n}}$ & loss: $\mathbb{R_{\text{0} \leq \text{x} \leq \text{1}}}$ & - \\
accuracy & prediction: float32$_{\text{m} \times \text{n}}$, target: float32$_{\text{m} \times \text{n}}$ & accuracy: $\mathbb{R_{\text{0} \leq \text{x} \leq \text{1}}}$ & - \\
confusionMatrix & prediction: float32$_{\text{m} \times \text{n}}$, target: float32$_{\text{m} \times \text{n}}$ & confusionMatrix: $\mathbb{R_{\text{0} \leq \text{x} \leq \text{1}}}^{26 \times 26}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

We assume that the prediction and target matrices are of the same dimensions.

\subsubsection{Access Routine Semantics}

\noindent crossEntropyLoss(prediction, target):
\begin{itemize}
\item output: loss := $f_{crossEntropyLoss}(prediction, target)$
\end{itemize}

\noindent accuracy(prediction, target):
\begin{itemize}
\item output: accuracy := $f_{accuracy}(prediction, target)$
\end{itemize}

\noindent confusionMatrix(prediction, target):
\begin{itemize}
\item output: confusionMatrix := $f_{confusionMatrix}(prediction, target)$

\end{itemize}

\subsubsection{Local Functions}

N/A

\section{MIS of Graphical User Interface Module} \label{MGUI}

\subsection{Module}

gui
\subsection{Uses}

\begin{itemize}
  \item Hardware-Hiding Module
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
- & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

\begin{itemize}
  \item displayWindow (dimensions: $\mathbb{Z}_+ \times \mathbb{Z}_+$)
  \item keyboard (keypress: char)
  \item mouse (location : $\mathbb{Z}_+ \times \mathbb{Z}_+$, click: bool)
\end{itemize}

\subsubsection{Assumptions}

This behavior will be sufficiently abstracted by the use of Python Notebook,
which will handle all UI elements and interactions with the user. As a result,
the GUI modules does not need to have any pre-defined state variables or access
routines.

\subsubsection{Access Routine Semantics}

N/A

\subsubsection{Local Functions}

N/A

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\end{document}